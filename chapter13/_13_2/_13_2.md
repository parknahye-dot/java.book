## 13-2 LIFO와 FIFO 컬렉션

컬렉션 프레임워크는 **LIFO(Last In First Out, 후입선출)** 와 **FIFO(First In First Out, 선입선출)** 자료 구조를 제공한다.  
- **LIFO**: 나중에 추가된 데이터가 먼저 나감 → Stack.  
- **FIFO**: 먼저 추가된 데이터가 먼저 나감 → Queue.  

---

#### Stack
- 후입선출(LIFO) 구조를 구현한 클래스.
- `push()`: 데이터 추가  
- `pop()`: 데이터 꺼내기  
- `peek()`: 마지막 데이터 확인  

**예시:**
```java
import java.util.Stack;

public class StackExample {
    public static void main(String[] args) {
        Stack<String> stack = new Stack<>();

        stack.push("Java");
        stack.push("Python");
        stack.push("C++");

        System.out.println(stack.peek()); // C++
        System.out.println(stack.pop());  // C++ (제거)
        System.out.println(stack.pop());  // Python
        System.out.println(stack);        // [Java]
    }
}
```

출력:
```
C++
C++
Python
[Java]
```

---

#### Queue
- 선입선출(FIFO) 구조를 구현한 인터페이스.
- 대표적인 구현체는 `LinkedList`.
- `offer()`: 데이터 추가  
- `poll()`: 데이터 꺼내기 (비어있으면 null 반환)  
- `peek()`: 첫 번째 데이터 확인  

**예시:**
```java
import java.util.LinkedList;
import java.util.Queue;

public class QueueExample {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();

        queue.offer("Task1");
        queue.offer("Task2");
        queue.offer("Task3");

        System.out.println(queue.peek()); // Task1
        System.out.println(queue.poll()); // Task1 제거
        System.out.println(queue.poll()); // Task2 제거
        System.out.println(queue);        // [Task3]
    }
}
```

출력:
```
Task1
Task1
Task2
[Task3]
```

---

### 정리
1. **Stack (LIFO)**: 마지막에 들어간 요소가 먼저 나온다. → `push()`, `pop()`, `peek()`.  
2. **Queue (FIFO)**: 먼저 들어간 요소가 먼저 나온다. → `offer()`, `poll()`, `peek()`.  
3. Stack은 주로 실행 취소, 수식 계산 등에, Queue는 작업 대기열, 버퍼 처리 등에 활용된다.  

# 마무리

## ▶ 4가지 키워드로 끝내는 핵심 포인트

• **Stack**: 후입선출(LIFO)을 구현한 클래스입니다.

• **Queue**: 선입선출(FIFO)에 필요한 메소드를 정의한 인터페이스입니다. 구현 클래스로는 LinkedList가 있습니다.

---

## ▶ 확인 문제

### 1. Stack과 Queue에 대한 설명입니다. 맞는 것에 O표, 틀린 것에 X표 하세요.

① Stack은 후입선출(LIFO)을 구현한 클래스이다. (    )
② Queue는 선입선출(FIFO)을 위한 위한 인터페이스이다. (    )
③ Stack의 push()는 객체를 넣을 때, pop()은 객체를 뺄 때 사용한다. (    )
④ Queue의 poll()은 객체를 넣을 때, offer()는 객체를 뺄 때 사용한다. (    )

**풀이**:
① Stack은 후입선출(LIFO)을 구현한 클래스이다. **(O)**
② Queue는 선입선출(FIFO)을 위한 위한 인터페이스이다. **(O)**
③ Stack의 push()는 객체를 넣을 때, pop()은 객체를 뺄 때 사용한다. **(O)**
④ Queue의 poll()은 객체를 넣을 때, offer()는 객체를 뺄 때 사용한다. **(X)**

**④번 해설**: Queue에서 **offer()는 객체를 넣을 때**, **poll()은 객체를 뺄 때** 사용합니다. 순서가 반대입니다.

---

## 추가 학습 내용

### Stack과 Queue의 특징

#### Stack (스택) - LIFO (Last In, First Out)
- **구조**: 한쪽 끝에서만 삽입과 삭제가 일어남
- **실생활 예시**: 접시 쌓기, 웹 브라우저의 뒤로 가기
- **주요 메소드**:
  - `push(E item)`: 스택 맨 위에 요소 추가
  - `pop()`: 스택 맨 위 요소 제거하고 반환
  - `peek()`: 스택 맨 위 요소 반환 (제거하지 않음)
  - `empty()`: 스택이 비어있는지 확인

#### Queue (큐) - FIFO (First In, First Out)  
- **구조**: 한쪽 끝에서 삽입, 다른 끝에서 삭제
- **실생활 예시**: 대기줄, 프린터 작업 대기열
- **주요 메소드**:
  - `offer(E e)`: 큐 끝에 요소 추가
  - `poll()`: 큐 앞의 요소 제거하고 반환
  - `peek()`: 큐 앞의 요소 반환 (제거하지 않음)
  - `isEmpty()`: 큐가 비어있는지 확인

### 실제 사용 예제

#### Stack 예제
```java
import java.util.Stack;

public class StackExample {
    public static void main(String[] args) {
        Stack<String> stack = new Stack<>();
        
        // 요소 추가
        stack.push("첫 번째");
        stack.push("두 번째");
        stack.push("세 번째");
        
        System.out.println("스택 상태: " + stack);
        
        // 요소 제거 (LIFO)
        System.out.println("pop: " + stack.pop());  // "세 번째"
        System.out.println("pop: " + stack.pop());  // "두 번째"
        System.out.println("peek: " + stack.peek()); // "첫 번째" (제거 안 함)
        System.out.println("pop: " + stack.pop());  // "첫 번째"
        
        System.out.println("스택이 비어있나? " + stack.empty());
    }
}
```

**실행 결과**:
```
스택 상태: [첫 번째, 두 번째, 세 번째]
pop: 세 번째
pop: 두 번째
peek: 첫 번째
pop: 첫 번째
스택이 비어있나? true
```

#### Queue 예제
```java
import java.util.Queue;
import java.util.LinkedList;

public class QueueExample {
    public static void main(String[] args) {
        Queue<String> queue = new LinkedList<>();
        
        // 요소 추가
        queue.offer("첫 번째");
        queue.offer("두 번째");
        queue.offer("세 번째");
        
        System.out.println("큐 상태: " + queue);
        
        // 요소 제거 (FIFO)
        System.out.println("poll: " + queue.poll());  // "첫 번째"
        System.out.println("poll: " + queue.poll());  // "두 번째"
        System.out.println("peek: " + queue.peek());  // "세 번째" (제거 안 함)
        System.out.println("poll: " + queue.poll());  // "세 번째"
        
        System.out.println("큐가 비어있나? " + queue.isEmpty());
    }
}
```

**실행 결과**:
```
큐 상태: [첫 번째, 두 번째, 세 번째]
poll: 첫 번째
poll: 두 번째
peek: 세 번째
poll: 세 번째
큐가 비어있나? true
```

### 실무 활용 사례

#### Stack 활용
1. **웹 브라우저 히스토리**: 뒤로 가기 기능
2. **함수 호출**: Call Stack
3. **괄호 검사**: 프로그래밍 언어의 괄호 매칭
4. **Undo 기능**: 텍스트 에디터의 실행 취소

```java
// 괄호 검사 예제
public class BracketChecker {
    public static boolean isValidBrackets(String str) {
        Stack<Character> stack = new Stack<>();
        
        for (char ch : str.toCharArray()) {
            if (ch == '(' || ch == '{' || ch == '[') {
                stack.push(ch);
            } else if (ch == ')' || ch == '}' || ch == ']') {
                if (stack.empty()) return false;
                
                char open = stack.pop();
                if (!isMatchingPair(open, ch)) return false;
            }
        }
        
        return stack.empty();
    }
    
    private static boolean isMatchingPair(char open, char close) {
        return (open == '(' && close == ')') ||
               (open == '{' && close == '}') ||
               (open == '[' && close == ']');
    }
}
```

#### Queue 활용
1. **프린터 작업 큐**: 인쇄 작업 대기열
2. **CPU 스케줄링**: 프로세스 실행 순서
3. **BFS (너비 우선 탐색)**: 그래프 탐색 알고리즘
4. **버퍼링**: 데이터 스트림 처리

```java
// 프린터 작업 큐 예제
public class PrinterQueue {
    private Queue<String> printQueue = new LinkedList<>();
    
    public void addPrintJob(String document) {
        printQueue.offer(document);
        System.out.println("인쇄 작업 추가: " + document);
    }
    
    public void processPrintJobs() {
        while (!printQueue.isEmpty()) {
            String document = printQueue.poll();
            System.out.println("인쇄 중: " + document);
            // 실제 인쇄 처리...
        }
    }
}
```

### Stack vs ArrayList 성능 비교
- **Stack**: Vector를 상속받아 synchronized 메소드 사용 (스레드 안전)
- **ArrayDeque**: 더 나은 성능, Stack 대신 권장

```java
import java.util.ArrayDeque;
import java.util.Deque;

public class ModernStackExample {
    public static void main(String[] args) {
        // ArrayDeque를 Stack처럼 사용 (권장)
        Deque<String> stack = new ArrayDeque<>();
        
        stack.push("요소1");  // addFirst()와 동일
        stack.push("요소2");
        
        System.out.println(stack.pop());  // removeFirst()와 동일
    }
}
```

### 주요 차이점 정리

| 구분 | Stack | Queue |
|------|-------|-------|
| **동작 방식** | LIFO (후입선출) | FIFO (선입선출) |
| **주요 메소드** | push(), pop(), peek() | offer(), poll(), peek() |
| **구현** | 클래스 (Vector 상속) | 인터페이스 (LinkedList 구현) |
| **활용** | 함수 호출, Undo 기능 | 대기열, 스케줄링 |