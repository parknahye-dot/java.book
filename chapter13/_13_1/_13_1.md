# Chapter 13 컬렉션 프레임워크

## 13-1 컬렉션 프레임워크

**컬렉션 프레임워크(Collection Framework)** 는 객체들을 효율적으로 저장하고 관리하기 위한 클래스와 인터페이스의 집합이다.  
대표적으로 **List, Set, Map** 인터페이스와 이를 구현한 다양한 클래스들이 제공된다.

---

#### List 컬렉션
- 순서를 유지하고, 중복 저장을 허용한다.
- 인덱스로 요소를 관리한다.
- 대표 클래스: **ArrayList, Vector, LinkedList**

##### ArrayList
- 내부적으로 배열을 사용하여 데이터를 저장.
- 인덱스 기반 접근 속도가 빠르다.
- 크기가 자동으로 늘어난다.

**예시:**
```java
import java.util.ArrayList;

ArrayList<String> list = new ArrayList<>();
list.add("Java");
list.add("Python");
list.add("C++");

System.out.println(list.get(0)); // Java
System.out.println(list.size()); // 3
```

##### Vector
- ArrayList와 동일한 구조지만 **동기화(Synchronization)** 지원.
- 멀티스레드 환경에서 안전하다.

**예시:**
```java
import java.util.Vector;

Vector<Integer> vec = new Vector<>();
vec.add(10);
vec.add(20);
System.out.println(vec.get(1)); // 20
```

##### LinkedList
- 양방향 연결 리스트로 구성.
- 삽입/삭제가 빈번한 경우 유리하다.

**예시:**
```java
import java.util.LinkedList;

LinkedList<String> list = new LinkedList<>();
list.add("A");
list.add("B");
list.addFirst("C");
System.out.println(list); // [C, A, B]
```

---

#### Set 컬렉션
- 순서를 유지하지 않고, 중복 저장을 허용하지 않는다.
- 대표 클래스: **HashSet**

##### HashSet
- 해시 알고리즘을 사용하여 검색 속도가 빠르다.
- 중복된 객체는 저장되지 않는다.

**예시:**
```java
import java.util.HashSet;

HashSet<String> set = new HashSet<>();
set.add("Java");
set.add("Python");
set.add("Java"); // 중복 저장 안됨

System.out.println(set); // [Java, Python]
```

---

#### Map 컬렉션
- 키(Key)와 값(Value) 쌍으로 데이터를 저장.
- 키는 중복을 허용하지 않고, 값은 중복 저장 가능.
- 대표 클래스: **HashMap, Hashtable**

##### HashMap
- 비동기 방식(Map 중 가장 많이 사용).
- 키와 값의 null 허용.

**예시:**
```java
import java.util.HashMap;

HashMap<String, Integer> map = new HashMap<>();
map.put("Java", 100);
map.put("Python", 95);
map.put("C++", 85);

System.out.println(map.get("Python")); // 95
```

##### Hashtable
- HashMap과 유사하지만 **동기화 지원**.
- 키와 값에 `null` 허용하지 않음.

**예시:**
```java
import java.util.Hashtable;

Hashtable<String, String> table = new Hashtable<>();
table.put("id", "hong");
table.put("pwd", "1234");

System.out.println(table.get("id")); // hong
```

---

### 정리
1. **List**: 순서 유지, 중복 허용 → ArrayList(빠른 접근), Vector(동기화), LinkedList(삽입/삭제 용이).  
2. **Set**: 순서 없음, 중복 불가 → HashSet.  
3. **Map**: 키-값 쌍 저장, 키 중복 불가 → HashMap(비동기), Hashtable(동기화).  

# 마무리

## ▶ 4가지 키워드로 끝내는 핵심 포인트

• **컬렉션 프레임워크**: 널리 알려져 있는 자료구조(Data Structure)를 사용해서 객체들을 효율적으로 추가, 삭제, 검색할 수 있도록 인터페이스와 구현 클래스들을 java.util 패키지에서 제공합니다. 이들을 총칭해서 컬렉션 프레임워크(Collection Framework)라고 부릅니다.

• **List 컬렉션**: List 컬렉션은 배열과 비슷하게 객체를 인덱스로 관리합니다. 배열과의 차이점은 저장 용량(capacity)이 자동으로 증가하며, 객체를 저장할 때 자동 인덱스가 부여된다는 것입니다. 그리고 추가, 삭제, 검색을 위한 다양한 메소드가 제공됩니다. List 컬렉션은 동일한 객체를 중복 저장할 수 있고 null도 저장이 가능합니다.

• **Set 컬렉션**: Set 컬렉션은 저장 순서가 유지되지 않습니다. 또한 객체를 중복해서 저장할 수 없고, 하나의 null만 저장할 수 있습니다. Set 컬렉션은 수학의 집합과 비슷합니다. 집합은 순서와 상관없고 중복이 허용되지 않기 때문입니다.

• **Map 컬렉션**: Map 컬렉션은 키(Key)와 값(Value)으로 구성된 Map.Entry 객체를 저장하는 구조를 가지고 있습니다. Entry는 Map 인터페이스 내부에 선언된 중첩 인터페이스입니다. 여기서 키와 값은 모두 객체입니다. 키는 중복 저장될 수 없지만 값은 중복 저장될 수 있습니다. 만약 기존에 저장된 키와 동일한 키로 값을 저장하면 기존의 값은 없어지고 새로운 값으로 대체됩니다.

---

## ▶ 확인 문제

### 1. 자바의 컬렉션 프레임워크에 대한 설명입니다. 맞는 것에 O표, 틀린 것에 X표 하세요.

① List 컬렉션은 인덱스로 객체를 관리하며 중복 저장을 허용한다. (    )
② Set 컬렉션은 순서를 유지하지 않으며 중복 저장을 허용하지 않는다. (    )
③ Map 컬렉션은 키와 값으로 구성된 Map.Entry를 저장한다. (    )
④ List와 Set은 모두 하나의 null만 저장 가능하다. (    )

**풀이**:
① List 컬렉션은 인덱스로 객체를 관리하며 중복 저장을 허용한다. **(O)**
② Set 컬렉션은 순서를 유지하지 않으며 중복 저장을 허용하지 않는다. **(O)**
③ Map 컬렉션은 키와 값으로 구성된 Map.Entry를 저장한다. **(O)**
④ List와 Set은 모두 하나의 null만 저장 가능하다. **(X)**

**④번 해설**: List는 null을 여러 개 저장할 수 있습니다. Set만 하나의 null만 저장 가능합니다.

---

### 2. List 컬렉션에 대한 설명입니다. 맞는 것에 O표, 틀린 것에 X표 하세요.

① 대표적인 구현 클래스로는 ArrayList, Vector, LinkedList가 있다. (    )
② 대부분의 구현 클래스들은 ArrayList보다는 Vector가 스레드에 안전하다. (    )
③ 빈번한 삽입과 삭제에는 ArrayList보다 삭제된 위치를 비워 놓지 않다. (    )
④ ArrayList에서 객체를 삭제하면 삭제된 곳을 LinkedList를 사용하는 것이 좋다. (    )

**풀이**:
① 대표적인 구현 클래스로는 ArrayList, Vector, LinkedList가 있다. **(O)**
② 대부분의 구현 클래스들은 ArrayList보다는 Vector가 스레드에 안전하다. **(O)**
③ 빈번한 삽입과 삭제에는 ArrayList보다 삭제된 위치를 비워 놓지 않다. **(X)**
④ ArrayList에서 객체를 삭제하면 삭제된 곳을 LinkedList를 사용하는 것이 좋다. **(X)**

**③④번 해설**: 문장이 불완전하지만, 빈번한 삽입/삭제에는 LinkedList가 ArrayList보다 유리합니다. ArrayList는 중간 삽입/삭제 시 배열 이동이 발생하지만, LinkedList는 노드 연결만 변경하면 됩니다.

---

### 3. Set 컬렉션에 대한 설명입니다. 맞는 것에 O표, 틀린 것에 X표 하세요.

① 대표적인 구현 클래스로는 HashSet, LinkedHashSet, TreeSet이 있다. (    )
② 대부분의 구현 클래스들은 Iterator를 이용한다. (    )
③ Set 컬렉션에서 객체를 하나씩 꺼내요 실다면 Iterator를 이용하여 중복된 객체를 관별한다. (    )
④ HashSet은 hashCode()와 equals()을 이용하여 중복된 객체를 판별한다. (    )
⑤ Set 컬렉션에는 null을 저장할 수 없다. (    )

**풀이**:
① 대표적인 구현 클래스로는 HashSet, LinkedHashSet, TreeSet이 있다. **(O)**
② 대부분의 구현 클래스들은 Iterator를 이용한다. **(O)**
③ Set 컬렉션에서 객체를 하나씩 꺼내요 실다면 Iterator를 이용하여 중복된 객체를 관별한다. **(X)**
④ HashSet은 hashCode()와 equals()을 이용하여 중복된 객체를 판별한다. **(O)**
⑤ Set 컬렉션에는 null을 저장할 수 없다. **(X)**

**③번 해설**: Iterator는 객체를 하나씩 꺼내기 위한 도구이지, 중복 객체 판별과는 관련이 없습니다.
**⑤번 해설**: Set에는 null을 하나만 저장할 수 있습니다.

---

### 4. Map 컬렉션에 대한 설명 중 틀린 것은 무엇입니까?

① 대표적인 구현 클래스로는 HashMap, Hashtable, TreeMap이 있다.
② HashMap과 Hashtable은 hashCode()와 equals()를 이용해서 중복 키를 판별한다.
③ 멀티 스레드 환경에서는 HashMap보다 Hashtable이 스레드에 안전하다.
④ Map 컬렉션에는 다른 키로 객체를 중복해서 저장할 수 없습니다.

**풀이**: 
**정답: ④**

**해설**:
- ① HashMap, Hashtable, TreeMap은 Map의 대표적인 구현 클래스입니다. ✓
- ② 해시 기반 Map들은 키의 hashCode()와 equals()로 중복을 판별합니다. ✓
- ③ Hashtable은 synchronized 메소드로 스레드 안전성을 보장합니다. ✓
- ④ **틀림**: Map에서는 키는 중복될 수 없지만, **값(Value)은 중복 저장이 가능**합니다.

---

### 5. 성급 스레드 환경에서 Board 객체를 저장 순서에 맞게 읽고 싶습니다. 가장 적합한 컬렉션을 생성하도록 빈줄 친 부분에 코드를 작성해보세요.

```
_____________ 변수 = new _____________
    (타입)              (생성자 호출)
```

**풀이**:
```
Vector<Board> 변수 = new Vector<Board>()
    (타입)              (생성자 호출)
```

**해설**:
- **저장 순서 유지**: List 컬렉션 필요
- **멀티 스레드 안전**: synchronized 메소드를 제공하는 Vector 선택
- ArrayList는 스레드 안전하지 않음
- LinkedList도 스레드 안전하지 않음

---

### 6. 성급 스레드 환경에서 학번(String)을 키로, 점수(Integer)를 값으로 저장하는 가장 적합한 컬렉션을 생성하도록 빈줄 친 부분에 코드를 작성해보세요.

```
_____________ 변수 = new _____________
    (타입)              (생성자 호출)
```

**풀이**:
```
Hashtable<String, Integer> 변수 = new Hashtable<String, Integer>()
    (타입)                           (생성자 호출)
```

**해설**:
- **키-값 저장**: Map 컬렉션 필요
- **멀티 스레드 안전**: synchronized 메소드를 제공하는 Hashtable 선택
- HashMap은 스레드 안전하지 않음

---

### 7. BoardDao 객체의 getBoardList() 메소드를 호출해서 List<Board> 타입의 컬렉션을 리턴합니다. ListExample 클래스를 실행할 때 다음과 같이 출력될 수 있도록 BoardDao의 getBoardList() 메소드를 작성해보세요.

**실행 결과**:
```
제목1-내용1
제목2-내용2
제목3-내용3
```

**풀이**:
```java
// BoardDao.java
import java.util.ArrayList;
import java.util.List;

public class BoardDao {
    public List<Board> getBoardList() {
        List<Board> list = new ArrayList<Board>();
        
        list.add(new Board("제목1", "내용1"));
        list.add(new Board("제목2", "내용2"));
        list.add(new Board("제목3", "내용3"));
        
        return list;
    }
}

// Board.java (필요한 클래스)
public class Board {
    private String title;
    private String content;
    
    public Board(String title, String content) {
        this.title = title;
        this.content = content;
    }
    
    public String getTitle() { return title; }
    public String getContent() { return content; }
}

// ListExample.java (사용 예제)
import java.util.List;

public class ListExample {
    public static void main(String[] args) {
        BoardDao dao = new BoardDao();
        List<Board> list = dao.getBoardList();
        for(Board board : list) {
            System.out.println(board.getTitle() + "-" + board.getContent());
        }
    }
}
```

---

### 8. HashSet에 Student 객체를 저장하려고 합니다. 학번이 같으면 동일한 Student라고 가정하고 중복 저장이 되지 않도록 하고 싶습니다. Student 클래스에서 재정의해야 하는 hashCode()와 equals() 메소드의 내용을 채워보세요. Student의 해시코드는 학번이라고 가정합니다.

**풀이**:
```java
// Student.java
public class Student {
    public int studentNum;
    public String name;
    
    public Student(int studentNum, String name) {
        this.studentNum = studentNum;
        this.name = name;
    }
    
    @Override
    public int hashCode() {
        return studentNum;  // 학번을 해시코드로 사용
    }
    
    @Override
    public boolean equals(Object obj) {
        if(obj instanceof Student) {
            Student student = (Student) obj;
            return studentNum == student.studentNum;
        }
        return false;
    }
}

// HashSetExample.java (사용 예제)
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class HashSetExample {
    public static void main(String[] args) {
        Set<Student> set = new HashSet<Student>();
        
        set.add(new Student(1, "홍길동"));
        set.add(new Student(2, "신용권"));
        set.add(new Student(1, "조민우"));  // 학번이 같으므로 저장되지 않음
        
        Iterator<Student> iterator = set.iterator();
        while(iterator.hasNext()) {
            Student student = iterator.next();
            System.out.println(student.studentNum + ":" + student.name);
        }
    }
}
```

**실행 결과**:
```
1:홍길동
2:신용권
```

---

### 9. HashMap에 아이디(String)와 점수(Integer)가 저장되어 있습니다. 실행결과와 같이 평균 점수를 출력하고, 최고 점수와 최고 점수를 받은 아이디를 출력해보세요.

**실행 결과**:
```
평균점수: 91
최고점수: 96
최고점수를 받은 아이디: blue
```

**풀이**:
```java
// MapExample.java
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class MapExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<String, Integer>();
        
        map.put("blue", 96);
        map.put("hong", 86);
        map.put("white", 92);
        
        String name = null;      // 최고 점수를 받은 아이디 저장
        int maxScore = 0;        // 최고 점수 저장
        int totalScore = 0;      // 점수 합계 저장
        
        // Map의 Entry들을 순회하면서 계산
        Set<Map.Entry<String, Integer>> entrySet = map.entrySet();
        for(Map.Entry<String, Integer> entry : entrySet) {
            String id = entry.getKey();
            int score = entry.getValue();
            
            totalScore += score;
            
            if(score > maxScore) {
                maxScore = score;
                name = id;
            }
        }
        
        int avgScore = totalScore / map.size();
        
        System.out.println("평균점수: " + avgScore);
        System.out.println("최고점수: " + maxScore);
        System.out.println("최고점수를 받은 아이디: " + name);
    }
}
```

**다른 방법 (Java 8 Stream 사용)**:
```java
// 평균 점수
double avgScore = map.values().stream().mapToInt(Integer::intValue).average().orElse(0);

// 최고 점수
int maxScore = map.values().stream().mapToInt(Integer::intValue).max().orElse(0);

// 최고 점수를 받은 아이디
String maxId = map.entrySet().stream()
    .max(Map.Entry.comparingByValue())
    .map(Map.Entry::getKey)
    .orElse(null);
```