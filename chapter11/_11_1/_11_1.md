# Chapter 11 기본 API 클래스

## java.lang 패키지

`java.lang` 패키지는 자바 프로그램에서 가장 기본적으로 제공되는 클래스들을 포함한다.  
별도의 import 없이 자동으로 제공된다.

---

#### 자바 API 도큐먼트
- 자바는 클래스 라이브러리와 함께 API 문서를 제공한다.
- API 문서에는 클래스, 인터페이스, 메소드, 필드의 사용법이 정리되어 있다.
- 예: [Java SE API Documentation](https://docs.oracle.com/javase/8/docs/api/)

---

#### API 도큐먼트에서 클래스 페이지 읽는 방법
- 상단에는 클래스의 패키지와 상속 관계가 표시된다.
- 중간에는 생성자와 메소드 목록이 표로 정리된다.
- 각 메소드에는 리턴 타입, 매개변수, 설명이 포함된다.

---

#### Object 클래스
모든 클래스의 최상위 부모 클래스.  
직접 상속을 지정하지 않으면 자동으로 `Object`를 상속한다.

##### 객체 비교 (equals())
- `==`: 주소(참조) 비교.
- `equals()`: 객체의 내용 비교.

```java
String str1 = new String("Java");
String str2 = new String("Java");

System.out.println(str1 == str2);      // false
System.out.println(str1.equals(str2)); // true
```

##### 객체 해시코드 (hashCode())
- 객체를 식별하는 정수값을 반환한다.
- `equals()`가 true라면 `hashCode()`도 동일해야 한다.

```java
String str = "Java";
System.out.println(str.hashCode()); // 동일 문자열은 동일 해시코드
```

##### 객체 문자 정보 (toString())
- 객체 정보를 문자열로 반환.
- 디버깅 시 객체 상태를 확인할 때 자주 사용.

```java
Integer obj = 100;
System.out.println(obj.toString()); // "100"
```

---

#### System 클래스
- 표준 입력/출력, 현재 시간, 시스템 종료 등을 제공하는 클래스.

##### 현재 시각 읽기 (currentTimeMillis(), nanoTime())
```java
long start = System.currentTimeMillis();
// 코드 실행
long end = System.currentTimeMillis();
System.out.println("실행 시간: " + (end - start) + "ms");
```

```java
long start = System.nanoTime();
// 코드 실행
long end = System.nanoTime();
System.out.println("실행 시간: " + (end - start) + "ns");
```

---

#### Class 클래스
- 클래스의 메타 정보를 얻을 수 있다.

```java
Class clazz = String.class;
System.out.println(clazz.getName()); // java.lang.String
```

##### 클래스 경로를 활용해서 리소스 절대 경로 읽기
```java
Class clazz = Class.forName("java.lang.String");
System.out.println(clazz.getResource("String.class"));
```

---

#### String 클래스
문자열을 다루는 가장 중요한 클래스.

##### String 생성자
```java
String str1 = new String("Java");
String str2 = "Java";
```

##### String 메소드
- `length()` : 문자열 길이 반환
- `charAt(int index)` : 특정 위치 문자 반환
- `substring(int start, int end)` : 부분 문자열 추출
- `equals(String other)` : 문자열 비교
- `replace(String old, String new)` : 문자열 치환
- `split(String regex)` : 구분자 기준 분리
- `trim()` : 앞뒤 공백 제거
- `toUpperCase()`, `toLowerCase()` : 대/소문자 변환

##### 박싱과 언박싱
- 기본 타입 → 포장 클래스 객체 (박싱)
- 포장 클래스 객체 → 기본 타입 (언박싱)

```java
Integer obj = Integer.valueOf(100); // 박싱
int value = obj.intValue();         // 언박싱
```

##### 자동 박싱과 언박싱
- 자바 5부터 자동 변환 지원.

```java
Integer obj = 100;   // 자동 박싱
int value = obj;     // 자동 언박싱
```

##### 문자열을 기본 타입 값으로 변환
```java
int num = Integer.parseInt("123");
double d = Double.parseDouble("3.14");
boolean b = Boolean.parseBoolean("true");
```

##### 포장 값 비교
- 포장 객체는 `==`로 비교하지 말고 `equals()` 사용.

```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b);      // true (캐싱된 값)
System.out.println(a.equals(b)); // true
```

```java
Integer x = 200;
Integer y = 200;
System.out.println(x == y);      // false (캐싱 범위 벗어남)
System.out.println(x.equals(y)); // true
```

---

#### Math 클래스
- 수학 계산을 위한 다양한 메소드 제공.

**주요 메소드**
| 메소드 | 설명 |
|--------|------|
| abs(a) | 절대값 |
| ceil(a) | 올림 |
| floor(a) | 내림 |
| max(a, b) | 최대값 |
| min(a, b) | 최소값 |
| pow(a, b) | 제곱 |
| random() | 0.0 <= 난수 < 1.0 |
| round(a) | 반올림 |

**예시:**
```java
System.out.println(Math.abs(-5));    // 5
System.out.println(Math.ceil(2.3));  // 3.0
System.out.println(Math.floor(2.7)); // 2.0
System.out.println(Math.max(3, 7));  // 7
System.out.println(Math.random());   // 0.0 ~ 1.0 사이 난수
```

---

### 정리
1. `java.lang` 패키지는 import 없이 사용 가능.  
2. `Object`: equals(), hashCode(), toString().  
3. `System`: 시간 측정, 입출력, 종료 기능.  
4. `Class`: 클래스 메타 정보.  
5. `String`: 문자열 생성자, 메소드, 박싱/언박싱, 변환.  
6. `Math`: 수학적 계산 유틸리티.  

# 마무리

## ▶ 6가지 키워드로 끝내는 핵심 포인트

• **Object 클래스**: 자바의 최상위 부모 클래스입니다. 따라서 Object 클래스의 메소드는 모든 자바 객체에서 사용할 수 있습니다.

• **System 클래스**: System 클래스를 이용하면 운영체제의 일부 기능을 이용할 수 있습니다. 프로그램 종료, 키보드로부터 입력, 모니터로 출력, 현재 시간 읽기 등이 가능합니다. System 클래스의 모든 필드와 메소드는 정적 필드와 정적 메소드로 구성되어 있습니다.

• **Class 클래스**: 자바는 클래스와 인터페이스의 메타 데이터를 Class 클래스로 관리합니다. 여기서 메타 데이터란 클래스의 이름, 생성자 정보, 필드 정보, 메소드 정보를 말합니다.

• **String 클래스**: 문자열 리터럴은 String 객체로 자동 생성되지만, String 클래스의 다양한 생성자를 이용해서 직접 String 객체를 생성할 수도 있습니다. String 객체는 문자열 조작을 위한 많은 메소드를 가지고 있습니다.

• **Wrapper(포장) 클래스**: 기본 타입의 값을 갖는 객체를 포장 객체라고 합니다. 포장 객체는 외부에서 변경할 수 없습니다. 기본 타입의 값을 포장 객체로 만드는 것을 박싱이라고 하고, 반대로 포장 객체로부터 기본 타입의 값을 얻는 것을 언박싱이라고 합니다.

• **Math 클래스**: 수학 계산에 사용할 수 있는 메소드를 제공하며, Math 클래스가 제공하는 메소드는 모두 정적 메소드이므로 Math 클래스로 바로 사용할 수 있습니다.

---

## ▶ 확인 문제

### 1. Object 클래스에 대한 설명 중 틀린 것은 무엇입니까?

① 모든 자바 클래스의 최상위 부모 클래스이다.
② Object의 equals() 메소드는 == 연산자와 동일하게 번지를 비교한다.
③ 동등 비교를 위해 equals()와 hashCode() 메소드를 재정의하는 것이 좋다.
④ Object의 toString() 메소드는 객체의 필드값을 문자열로 리턴한다.

**풀이**: 
**정답: ④**

**해설**:
- ① 모든 Java 클래스는 Object 클래스를 상속받습니다. ✓
- ② Object의 equals() 메소드는 기본적으로 == 연산자와 같이 객체의 번지를 비교합니다. ✓
- ③ 객체의 내용을 비교하려면 equals()와 hashCode()를 함께 재정의해야 합니다. ✓
- ④ **틀림**: Object의 toString() 메소드는 "클래스명@16진수해시코드" 형태의 문자열을 리턴합니다. 필드값을 리턴하지 않습니다.

---

### 2. 여러분이 작성하는 클래스들 동등 비교하는 컬렉션 객체인 HashSet, HashMap, Hashtable을 사용하려고 합니다. Object의 equals()와 hashCode() 메소드를 재정의해야 가장 좋을 메소드 호출 순서를 (    ) 안을 채워보세요.

```
(        ) 리턴값 ──같음──> (        ) 리턴값 ──true──> 동등 객체
    │                        │
   다름                     false
    │                        │
    ↓                        ↓
  다른 객체                다른 객체
```

**풀이**:
```
(hashCode()) 리턴값 ──같음──> (equals()) 리턴값 ──true──> 동등 객체
    │                          │
   다름                       false
    │                          │
    ↓                          ↓
  다른 객체                  다른 객체
```

**해설**:
- 컬렉션에서 객체의 동등성을 판단할 때 성능 최적화를 위해 먼저 hashCode()를 비교
- hashCode()가 다르면 바로 다른 객체로 판단 (빠른 판단)
- hashCode()가 같으면 equals()를 호출하여 실제 내용 비교
- equals()가 true를 반환해야 최종적으로 동등 객체로 판단

---

### 3. Student 클래스를 작성하되, Object의 equals()와 hashCode()를 재정의해서 Student의 학번(studentNum)이 같으면 동등 객체가 될 수 있도록 해보세요. Student 클래스의 필드는 다음과 같습니다. hashCode()의 리턴값은 studentNum 필드값의 해시코드를 리턴하도록 하세요.

**풀이**:
```java
// Student.java
public class Student {
    private String studentNum;
    
    public Student(String studentNum) {
        this.studentNum = studentNum;
    }
    
    public String getStudentNum() {
        return studentNum;
    }
    
    // equals() 메소드 재정의
    @Override
    public boolean equals(Object obj) {
        if(obj instanceof Student) {
            Student student = (Student) obj;
            if(studentNum.equals(student.studentNum)) {
                return true;
            }
        }
        return false;
    }
    
    // hashCode() 메소드 재정의
    @Override
    public int hashCode() {
        return studentNum.hashCode();
    }
}
```

**사용 예제**:
```java
public class StudentExample {
    public static void main(String[] args) {
        //Student 키로 총점을 저장하는 HashMap 객체 생성
        HashMap<Student, String> hashMap = new HashMap<Student, String>();
        
        //new Student("1")의 점수 95를 저장
        hashMap.put(new Student("1"), "95");
        
        //new Student("1")로 점수를 읽어옴
        String score = hashMap.get(new Student("1"));
        System.out.println("1번 학생의 총점: " + score);
    }
}
```

**실행 결과**: `1번 학생의 총점: 95`

---

### 4. Member 클래스를 작성하되, Object의 toString() 메소드를 재정의해서 MemberExample 클래스의 실행결과처럼 나오도록 작성해보세요.

**풀이**:
```java
// Member.java
public class Member {
    private String id;
    private String name;
    
    public Member(String id, String name) {
        this.id = id;
        this.name = name;
    }
    
    // toString() 메소드 재정의
    @Override
    public String toString() {
        return id + ": " + name;
    }
}
```

**사용 예제**:
```java
// MemberExample.java
public class MemberExample {
    public static void main(String[] args) {
        Member member = new Member("blue", "이미란");
        System.out.println(member);
    }
}
```

**실행 결과**: `blue: 이미란`

---

### 5. Class 객체에 대한 설명 중 틀린 것은 무엇입니까?

① Class.forName() 메소드 또는 객체의 getClass() 메소드로 얻을 수 있다.
② 클래스의 생성자, 필드, 메소드에 대한 정보를 알아낼 수 있다.
③ 클래스 파일을 기준으로 상대 경로의 리소스의 정보를 알아낼 수 있다.
④ 클래스.class로 Class 객체를 얻을 수 없다.

**풀이**: 
**정답: ④**

**해설**:
- ① Class.forName("클래스명")과 객체.getClass()로 Class 객체를 얻을 수 있습니다. ✓
- ② 리플렉션을 통해 클래스의 구조 정보를 얻을 수 있습니다. ✓
- ③ getResource() 메소드로 리소스 정보를 얻을 수 있습니다. ✓
- ④ **틀림**: `클래스명.class` 방식으로도 Class 객체를 얻을 수 있습니다.

**Class 객체 획득 방법**:
```java
// 방법 1: .class 리터럴
Class clazz1 = String.class;

// 방법 2: forName() 메소드
Class clazz2 = Class.forName("java.lang.String");

// 방법 3: getClass() 메소드
String str = "Hello";
Class clazz3 = str.getClass();
```

---

### 6. 다음에 주어진 바이트 배열 ( 73, 32, 108, 111, 118, 101, 32, 121, 111, 117 )을 문자열로 변환해보세요.

**풀이**:
```java
// BytesToStringExample.java
public class BytesToStringExample {
    public static void main(String[] args) {
        byte[] bytes = { 73, 32, 108, 111, 118, 101, 32, 121, 111, 117 };
        String str = new String(bytes);
        System.out.println( str );
    }
}
```

**실행 결과**: `I love you`

**해설**: 바이트 배열을 String 생성자에 전달하면 각 바이트값이 ASCII 코드로 해석되어 문자열로 변환됩니다.

---

### 7. 문자열 "모든 프로그램은 자바 언어로 개발될 수 있다."에서 "자바" 문자열이 포함되어 있는지 확인하고, "자바"를 Java로 대치한 새로운 문자열을 만들어보세요.

**풀이**:
```java
// FindAndReplaceExample.java
public class FindAndReplaceExample {
    public static void main(String[] args) {
        String str = "모든 프로그램은 자바 언어로 개발될 수 있다.";
        int index = str.indexOf("자바");
        if(index == -1) {
            System.out.println("자바 문자열이 포함되어 있지 않습니다.");
        } else {
            System.out.println("자바 문자열이 포함되어 있습니다.");
            str = str.replace("자바", "Java");
            System.out.println("-->" + str);
        }
    }
}
```

**실행 결과**:
```
자바 문자열이 포함되어 있습니다.
-->모든 프로그램은 Java 언어로 개발될 수 있다.
```

---

### 8. 박싱된 Integer 객체를 == 연산자로 비교했습니다. 100을 박싱한 Integer 객체는 true, 나오는데, 300을 박싱한 Integer 객체는 false가 나오는 이유를 설명해보세요.

**풀이**:
```java
// IntegerCompareExample.java
public class IntegerCompareExample {
    public static void main(String[] args) {
        Integer obj1 = 100;
        Integer obj2 = 100;
        Integer obj3 = 300;
        Integer obj4 = 300;
        
        System.out.println( obj1 == obj2 );
        System.out.println( obj3 == obj4 );
    }
}
```

**실행 결과**:
```
true
false
```

**해설**:
- **100의 경우 (true)**: Java는 성능 최적화를 위해 -128부터 127까지의 Integer 객체를 미리 생성해서 캐시에 보관합니다. 따라서 같은 값을 박싱하면 같은 객체를 참조하므로 == 비교에서 true가 나옵니다.

- **300의 경우 (false)**: 300은 캐시 범위를 벗어나므로 매번 새로운 Integer 객체가 생성됩니다. 따라서 다른 객체를 참조하므로 == 비교에서 false가 나옵니다.

**올바른 비교 방법**: 포장 객체의 값을 비교할 때는 equals() 메소드를 사용해야 합니다.
```java
System.out.println( obj3.equals(obj4) );  // true
```

---

### 9. 문자열 "200"을 정수로 변환하는 코드와 숫자 150을 문자열로 변환하는 코드를 ①~②에 작성해보세요.

**풀이**:
```java
// StringConvertExample.java
public class StringConvertExample {
    public static void main(String[] args) {
        String strData1 = "200";
        int intData1 = Integer.parseInt(strData1);        // ①
        
        int intData2 = 150;
        String strData2 = String.valueOf(intData2);       // ②
    }
}
```

**해설**:
- **① String → int**: `Integer.parseInt(문자열)` 또는 `Integer.valueOf(문자열)`
- **② int → String**: `String.valueOf(숫자)` 또는 `숫자 + ""`

**다른 변환 방법들**:
```java
// String → int
int intData1 = Integer.parseInt(strData1);
int intData1 = Integer.valueOf(strData1);

// int → String  
String strData2 = String.valueOf(intData2);
String strData2 = Integer.toString(intData2);
String strData2 = intData2 + "";
```