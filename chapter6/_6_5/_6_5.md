## 6-5 인스턴스 멤버와 정적 멤버

클래스의 멤버는 크게 **인스턴스 멤버**와 **정적 멤버(static 멤버)** 로 나눌 수 있다.  
- 인스턴스 멤버: 객체마다 독립적으로 존재.  
- 정적 멤버: 모든 객체가 공유하는 멤버.  

---

##### 인스턴스 멤버
- 객체(인스턴스)를 생성해야 사용할 수 있는 필드와 메소드.  
- 각 객체마다 독립적으로 존재한다.

**예시:**
```java
public class Car {
    String model; // 인스턴스 필드
    
    void run() {  // 인스턴스 메소드
        System.out.println(model + "가 달립니다.");
    }
}
Car car1 = new Car();
car1.model = "소나타";
car1.run(); // 소나타가 달립니다.
```

---

##### 정적 멤버
- `static` 키워드를 붙이면 클래스에 고정된 멤버가 된다.
- 모든 객체가 공유한다.

**예시:**
```java
public class Calculator {
    static double pi = 3.14159; // 정적 필드
    
    static int plus(int x, int y) { // 정적 메소드
        return x + y;
    }
}
System.out.println(Calculator.pi);         // 3.14159
System.out.println(Calculator.plus(5, 10)); // 15
```

---

#### 인스턴스 멤버와 this

##### 인스턴스 멤버 선언
- `static` 키워드가 없는 필드와 메소드.

##### this
- 인스턴스 자신을 참조하는 키워드.  
- 인스턴스 메소드나 생성자에서 사용 가능.  
- 정적 메소드에서는 사용할 수 없음.

**예시:**
```java
public class Car {
    String model;
    
    Car(String model) {
        this.model = model; // this는 생성된 객체 자기 자신
    }
    
    void printModel() {
        System.out.println(this.model);
    }
}
```

---

#### 정적 멤버와 static

##### 정적 멤버 선언
- `static` 키워드를 붙여 선언.
- 클래스에 속하기 때문에 객체 생성 없이도 사용 가능.

##### 정적 멤버 사용
- 클래스 이름으로 직접 접근하는 것이 권장된다.
```java
System.out.println(Calculator.pi);
```

##### 정적 메소드 선언 시 주의할 점
- 정적 메소드 내부에서는 인스턴스 멤버에 직접 접근할 수 없다.
- 반드시 객체를 생성한 후 참조 변수로 접근해야 한다.

**잘못된 예시:**
```java
public class Car {
    String model;
    static void printModel() {
        System.out.println(model); // 오류! 인스턴스 멤버 접근 불가
    }
}
```

**올바른 예시:**
```java
public class Car {
    String model = "소나타";
    static void printModel(Car c) {
        System.out.println(c.model);
    }
}
```

---

#### 싱글 톤
- 프로그램 전체에서 단 하나의 객체만 생성하도록 보장하는 패턴.  
- 생성자를 `private`으로 막고, 정적 메소드를 통해 객체를 제공한다.

**예시:**
```java
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton() {}
    
    public static Singleton getInstance() {
        return instance;
    }
}
Singleton obj1 = Singleton.getInstance();
Singleton obj2 = Singleton.getInstance();
System.out.println(obj1 == obj2); // true
```

---

#### final 필드와 상수

##### final 필드
- 한 번 초기화하면 수정할 수 없는 필드.
- 객체마다 가질 수 있으며, 생성자에서 초기화 가능.

**예시:**
```java
public class Car {
    final String model; // 반드시 초기화 필요
    
    Car(String model) {
        this.model = model;
    }
}
```

##### 상수
- `static final`로 선언된 필드.  
- 클래스 차원에서 하나만 존재하며, 수정할 수 없다.  
- 상수명은 관례적으로 모두 대문자와 언더스코어 사용.

**예시:**
```java
public class Constants {
    static final double PI = 3.14159;
    static final int MAX_VALUE = 100;
}
System.out.println(Constants.PI);
```

---

### 정리
1. 인스턴스 멤버: 객체마다 독립적으로 존재, this 사용 가능.  
2. 정적 멤버: 클래스에 속하며, 모든 객체가 공유.  
3. 정적 메소드에서는 인스턴스 멤버 사용 불가.  
4. 싱글 톤 패턴: 객체를 하나만 생성해 공유.  
5. final 필드: 한 번 초기화 후 변경 불가.  
6. 상수(static final): 프로그램 전체에서 공유되는 불변 값.  

# 마무리

## ▶ 7가지 키워드로 끝내는 핵심 포인트

• **인스턴스 멤버**: 인스턴스(instance) 멤버란 객체(인스턴스)를 생성한 후 사용할 수 있는 필드와 메소드를 말하는데, 이들을 각각 인스턴스 필드, 인스턴스 메소드라고 부릅니다.

• **this**: 객체 내부에서도 인스턴스 멤버에 접근하기 위해 this를 사용할 수 있습니다. 예를 들어 this.model은 자신이 가지고 있는 model 필드라는 뜻입니다. this는 주로 생성자와 메소드의 매개 변수 이름이 필드와 동일한 경우, 인스턴스 멤버인 필드임을 명시하고자 할 때 사용됩니다.

• **정적 멤버**: 클래스에 고정된 멤버로서 객체를 생성하지 않고 사용할 수 있는 필드와 메소드를 말합니다. 이들을 각각 정적 필드, 정적 메소드라고 부릅니다.

• **static**: 정적 멤버를 선언할 때 사용하는 키워드입니다.

• **싱글톤**: 전체 프로그램에서 단 하나의 객체만 만들도록 보장해야 하는 경우가 있습니다. 단 하나만 생성된다고 해서 이 객체를 싱글톤(singleton)이라고 합니다.

• **final 필드**: 초기값이 저장되면 이것이 최종적인 값이 되어서 프로그램 실행 도중에 수정할 수 없는 필드를 말합니다. final 필드는 final 키워드로 선언합니다.

• **상수**: 수학에서 사용되는 원주율 파이(π)나 지구의 무게 및 둘레 같은 불변의 값을 저장하는 필드를 자바에서는 상수(constant)라고 합니다. 상수는 final static 키워드로 선언합니다.

---

## ▶ 확인 문제

### 1. 인스턴스 멤버와 정적 멤버에 대한 설명 중 맞는 것에 O표, 틀린 것에 X표 하세요.

① 정적 멤버는 static으로 선언된 필드와 메소드를 말한다. (    )
② 인스턴스 필드는 생성자에서 초기화될 수 없다. (    )
③ 정적 필드와 메소드는 객체 생성 없이 클래스를 통해 접근할 수 있다. (    )
④ 인스턴스 필드와 메소드는 객체를 생성하고 사용해야 한다. (    )

**풀이**:
① 정적 멤버는 static으로 선언된 필드와 메소드를 말한다. **(O)**
② 인스턴스 필드는 생성자에서 초기화될 수 없다. **(X)**
③ 정적 필드와 메소드는 객체 생성 없이 클래스를 통해 접근할 수 있다. **(O)**
④ 인스턴스 필드와 메소드는 객체를 생성하고 사용해야 한다. **(O)**

**②번 해설**: 인스턴스 필드는 생성자에서 초기화될 수 있습니다. 실제로 생성자의 주요 역할 중 하나가 인스턴스 필드를 초기화하는 것입니다.

---

### 2. final 필드의 성격(static, final)에 대한 설명으로 틀린 것은 무엇입니까?

① final 필드와 상수는 초기값이 저장되면 값을 변경할 수 없다.
② final 필드와 상수는 생성자에서 초기화될 수 있다.
③ 상수의 이름은 대문자로 작성하는 것이 관례이다.
④ 상수는 객체 생성 없이 클래스를 통해 사용할 수 있다.

**풀이**: 
**정답: ②**

**해설**:
- ① final 필드와 상수는 한 번 값이 저장되면 변경할 수 없습니다. ✓
- ② **틀림**: 상수(final static)는 생성자에서 초기화될 수 없습니다. 상수는 선언과 동시에 초기화하거나 정적 초기화 블록에서만 초기화 가능합니다. final 필드는 생성자에서 초기화 가능하지만, 상수는 불가능합니다.
- ③ 상수는 대문자와 언더스코어(_)로 작성하는 것이 관례입니다. ✓  
- ④ 상수는 static이므로 클래스명으로 접근 가능합니다. ✓

---

### 3. ShopService 객체를 싱글톤으로 만들고 싶습니다. ShopServiceExample 클래스에서 ShopService의 getInstance() 메소드로 싱글톤을 얻을 수 있도록 ShopService 클래스를 작성해보세요.

**풀이**:
```java
// ShopService.java
public class ShopService {
    // 정적 필드로 유일한 인스턴스 저장
    private static ShopService instance = new ShopService();
    
    // 생성자를 private으로 선언하여 외부에서 객체 생성 방지
    private ShopService() {}
    
    // 유일한 인스턴스를 반환하는 정적 메소드
    public static ShopService getInstance() {
        return instance;
    }
}
```

**사용 예제 (ShopServiceExample.java)**:
```java
public class ShopServiceExample {
    public static void main(String[] args) {
        ShopService obj1 = ShopService.getInstance();
        ShopService obj2 = ShopService.getInstance();
        
        if(obj1 == obj2) {
            System.out.println("같은 ShopService 객체입니다.");
        } else {
            System.out.println("다른 ShopService 객체입니다.");
        }
    }
}
```

**실행 결과**: `같은 ShopService 객체입니다.`

**싱글톤 패턴의 핵심**:
1. **private 생성자**: 외부에서 new로 객체 생성을 막음
2. **static 필드**: 클래스 로딩 시 하나의 인스턴스만 생성
3. **public static 메소드**: 유일한 인스턴스에 접근하는 방법 제공
4. **같은 참조값**: 여러 번 호출해도 항상 동일한 객체 반환