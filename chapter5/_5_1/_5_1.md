# Chapter5 참조 타입

## 5-1 참조 타입과 참조 변수

자바에서 데이터 타입은 크게 **기본 타입(Primitive Type)** 과 **참조 타입(Reference Type)** 으로 나뉜다.  
기본 타입은 실제 값을 변수에 저장하지만, 참조 타입은 **객체의 메모리 주소(참조 값)** 를 변수에 저장한다.

---

#### 기본 타입과 참조 타입

| 구분 | 기본 타입 (Primitive) | 참조 타입 (Reference) |
|------|----------------------|-----------------------|
| 저장 방식 | 값 자체 저장 | 객체의 주소(참조값) 저장 |
| 크기 | 고정 (byte, short, int, long, float, double, char, boolean) | 가변 (객체의 크기에 따라 달라짐) |
| 예시 | int a = 10; | String str = new String("Hello"); |
| 비교 | 값 자체를 비교 | 주소값(참조)을 비교 |

- 기본 타입 변수: 스택(Stack) 영역에 값이 직접 저장됨.
- 참조 타입 변수: 스택에는 **주소값**이 저장되고, 실제 객체는 힙(Heap) 영역에 생성됨.

---

#### 메모리 사용 영역

JVM에서 프로그램이 실행될 때 메모리는 크게 **메소드 영역, 힙 영역, JVM 스택 영역**으로 구분된다.

##### 메소드 영역
- 클래스의 바이트 코드, static 변수, 상수, 메소드 코드 등이 저장된다.
- 모든 스레드가 공유하는 영역.

##### 힙 영역
- new 연산자로 생성된 객체와 배열이 저장된다.
- 가비지 컬렉터(GC)가 사용하지 않는 객체를 제거한다.
- 참조 타입의 실제 데이터가 이곳에 저장된다.

##### JVM 스택 영역
- 각 스레드마다 생성된다.
- 메소드 호출 시 프레임이 쌓이고, 종료되면 프레임이 제거된다.
- 기본 타입 변수와 참조 타입 변수(주소값)가 저장된다.

**예시 그림 (개념):**
```
[Stack]        [Heap]
int a=10  -->  X
String s ---->  "Hello" 객체
```

---

#### 참조 변수의 ==, != 연산
- 기본 타입: 변수에 저장된 **값 자체**를 비교.
- 참조 타입: 변수에 저장된 **주소값**을 비교.

**예시:**
```java
String str1 = new String("Hello");
String str2 = new String("Hello");
System.out.println(str1 == str2);      // false (주소 다름)
System.out.println(str1.equals(str2)); // true (문자열 값 같음)
```

- `==` : 동일한 객체인지(주소 비교).  
- `.equals()` : 동일한 데이터인지(내용 비교).  

---

#### null과 NullPointerException
- 참조 변수가 아무 객체도 참조하지 않을 경우 값은 `null`이다.
- `null` 상태에서 객체의 필드나 메소드를 사용하면 `NullPointerException` (NPE)이 발생한다.

**예시:**
```java
String str = null;
System.out.println(str.length()); // NullPointerException 발생
```

- 해결 방법:
  - 객체 생성 확인 후 사용.
  - null 체크 코드 작성.

```java
if (str != null) {
    System.out.println(str.length());
}
```

---

#### String 타입
- 문자열을 표현하는 참조 타입.
- `new` 연산자로 생성할 수도 있고, 리터럴로 바로 할당할 수도 있다.
- 문자열 리터럴은 JVM 메모리의 **String Pool(상수 저장소)** 에 저장된다.

**예시:**
```java
String str1 = "Java";
String str2 = "Java";
System.out.println(str1 == str2); // true (동일한 상수 풀 참조)
```

- new 연산자 사용:
```java
String str3 = new String("Java");
String str4 = new String("Java");
System.out.println(str3 == str4);      // false (주소 다름)
System.out.println(str3.equals(str4)); // true (문자열 값 같음)
```

- 주요 메소드:
| 메소드 | 설명 | 예시 |
|--------|------|------|
| length() | 문자열 길이 반환 | "Java".length() → 4 |
| charAt(int index) | 특정 인덱스 문자 반환 | "Java".charAt(0) → 'J' |
| substring(int begin, int end) | 부분 문자열 | "Java".substring(0,2) → "Ja" |
| equals(Object obj) | 문자열 비교 | "Java".equals("java") → false |
| toUpperCase() | 대문자 변환 | "java" → "JAVA" |
| toLowerCase() | 소문자 변환 | "JAVA" → "java" |

---

### 정리
1. **기본 타입**은 값 저장, **참조 타입**은 객체 주소 저장.  
2. JVM 메모리: **메소드 영역, 힙 영역, 스택 영역**.  
3. 참조 변수의 `==`는 주소 비교, `.equals()`는 값 비교.  
4. 참조 변수는 `null`을 가질 수 있고, 잘못 쓰면 `NullPointerException`.  
5. **String 타입**은 참조 타입이지만 기본 타입처럼 많이 사용되며, 상수 풀에서 관리된다.  

# 마무리

## ▶ 6가지 키워드로 끝내는 핵심 포인트

• **기본 타입**: byte, short, char, int, long, float, double, boolean 타입을 말하며 이들 타입의 변수에는 값 자체가 저장됩니다.

• **참조 타입**: 기본 타입을 제외한 배열, 열거, 클래스, 인터페이스 등을 말합니다. 참조 타입의 변수에는 객체의 번지가 저장됩니다. 번지로 객체를 참조한다는 의미에서 참조 타입이라고 합니다.

• **메모리 사용 영역**: JVM은 운영체제에서 할당받은 메모리 영역을 메소드 영역, 힙 영역, 스택 영역으로 구분해서 사용합니다. 메소드 영역에는 정적 필드, 상수, 메소드 코드, 생성자 코드가 위치하며, 힙 영역에는 객체가 생성됩니다. 그리고 스택 영역에는 변수가 생성됩니다.

• **번지 비교**: 비교 연산자(==, !=)가 기본 타입에서 사용되면 값을 비교하지만, 참조 타입에서 사용되면 번지를 비교합니다. ==이 true가 나오면 같은 객체를 참조하는 뜻이고 false가 나오면 다른 객체를 참조하는 뜻입니다.

• **null**: 참조 타입 변수는 객체를 참조하지 않는다는 뜻으로 null 값을 가질 수 있습니다. null 값도 초기값으로 사용할 수 있기 때문에 null로 초기화된 참조 변수는 스택 영역에 생성됩니다.

• **NullPointerException**: 참조 변수가 null을 가지고 있을 경우에는, 참조 객체가 없으므로 참조 변수를 통해 객체를 사용할 수 없습니다. 만약 null인 참조 변수를 통해 있지도 않은 객체의 필드나 메소드를 사용하면 NullPointerException이 발생합니다.

---

## ▶ 확인 문제

### 1. 참조 타입에 대한 설명입니다. 맞는 것에 O표, 틀린 것에 X표 하세요.

① 참조 타입에는 배열, 열거, 클래스, 인터페이스가 있다. (    )
② 참조 변수의 메모리 생성 위치는 스택이다. (    )
③ 참조 타입에서 ==, != 연산자는 객체 번지를 비교한다. (    )
④ 참조 변수는 null 값으로 초기화할 수 없다. (    )

**풀이**:
① 참조 타입에는 배열, 열거, 클래스, 인터페이스가 있다. **(O)**
② 참조 변수의 메모리 생성 위치는 스택이다. **(O)**
③ 참조 타입에서 ==, != 연산자는 객체 번지를 비교한다. **(O)**
④ 참조 변수는 null 값으로 초기화할 수 없다. **(X)**

**④번 해설**: 참조 변수는 null 값으로 초기화할 수 있습니다. null은 참조하는 객체가 없다는 의미입니다.

---

### 2. 자바에서 메모리 사용에 대한 설명 중 맞는 것에 O표, 틀린 것에 X표 하세요.

① 로컬 변수는 스택 영역에 생성되며 실행 블록을 끝내면 소멸됩니다. (    )
② 상수, 메소드 코드, 생성자 코드는 메소드 영역에 생성된다. (    )
③ 참조되지 않는 객체는 프로그램에서 직접 소멸 코드를 작성하는 것이 좋다. (    )
④ 배열 및 객체는 힙 영역에 생성된다. (    )

**풀이**:
① 로컬 변수는 스택 영역에 생성되며 실행 블록을 끝내면 소멸됩니다. **(O)**
② 상수, 메소드 코드, 생성자 코드는 메소드 영역에 생성된다. **(O)**
③ 참조되지 않는 객체는 프로그램에서 직접 소멸 코드를 작성하는 것이 좋다. **(X)**
④ 배열 및 객체는 힙 영역에 생성된다. **(O)**

**③번 해설**: Java에서는 가비지 컬렉터(Garbage Collector)가 참조되지 않는 객체를 자동으로 소멸시킵니다. 프로그래머가 직접 소멸 코드를 작성할 필요가 없습니다.

---

### 3. String 타입에 대한 설명 중 맞는 것에 O표, 틀린 것에 X표 하세요.

① String은 클래스이므로 참조 타입이다. (    )
② String의 문자열 비교는 ==을 사용해야 한다. (    )
③ 동일한 문자열 리터럴을 저장하는 변수는 동일한 String 객체를 참조한다. (    )
④ new String("문자열")은 무조건 새로운 String 객체를 생성한다. (    )

**풀이**:
① String은 클래스이므로 참조 타입이다. **(O)**
② String의 문자열 비교는 ==을 사용해야 한다. **(X)**
③ 동일한 문자열 리터럴을 저장하는 변수는 동일한 String 객체를 참조한다. **(O)**
④ new String("문자열")은 무조건 새로운 String 객체를 생성한다. **(O)**

**②번 해설**: String의 문자열 비교는 `equals()` 메소드를 사용해야 합니다. `==`은 번지를 비교하므로 문자열 내용이 같아도 다른 객체라면 false가 됩니다.

---

### 4. 참조 변수에 대한 설명입니다. 맞는 것에 O표, 틀린 것에 X표 하세요.

① 참조 변수에 저장되는 것은 객체의 번지이다. (    )
② 참조 변수에 null을 저장해서 변수를 초기화시킬 수 있다. (    )
③ 참조 변수에 null이 저장된 상태에서는 객체를 사용할 수 없다. (    )
④ NullPointerException은 초기화되지 않은 참조 변수에서 발생한다. (    )

**풀이**:
① 참조 변수에 저장되는 것은 객체의 번지이다. **(O)**
② 참조 변수에 null을 저장해서 변수를 초기화시킬 수 있다. **(O)**
③ 참조 변수에 null이 저장된 상태에서는 객체를 사용할 수 없다. **(O)**
④ NullPointerException은 초기화되지 않은 참조 변수에서 발생한다. **(X)**

**④번 해설**: NullPointerException은 참조 변수가 null 값을 가지고 있을 때, 해당 변수를 통해 객체의 필드나 메소드에 접근하려고 할 때 발생합니다.

---

### 5. 다음 코드를 보고 비교 연산자와 메소드의 실행결과를 빈칸에 기술하세요.

```java
int var1 = 10;
int var2 = 10;
String var3 = "AB";
String var4 = "AB";
String var5 = new String("AB");
```

① var1 == var2        (    )
② var1 != var2        (    )
③ var3 == var4        (    )
④ var3 != var5        (    )
⑤ var4.equals(var5)   (    )

**풀이**:
① var1 == var2        **(true)**
② var1 != var2        **(false)**
③ var3 == var4        **(true)**
④ var3 != var5        **(true)**
⑤ var4.equals(var5)   **(true)**

**상세 해설**:
- **①, ②**: 기본 타입 int의 값 비교이므로 값이 같으면 true, 다르면 false
- **③**: 문자열 리터럴 "AB"는 같은 객체를 참조하므로 번지가 같아서 true
- **④**: var3는 문자열 리터럴, var5는 new로 생성한 새 객체이므로 번지가 다르므로 true
- **⑤**: equals() 메소드는 문자열 내용을 비교하므로 "AB"와 "AB"가 같아서 true

**메모리 구조**:
```
스택 영역:
var3 → 힙 영역의 "AB" 객체 (주소: 100번지)
var4 → 힙 영역의 "AB" 객체 (주소: 100번지) // 같은 객체 참조
var5 → 힙 영역의 "AB" 객체 (주소: 200번지) // new로 생성한 새 객체

힙 영역:
100번지: "AB" 객체 (문자열 리터럴)
200번지: "AB" 객체 (new로 생성)
```

---

## 추가 학습 포인트

### 메모리 영역 구분
1. **메소드 영역**: 바이트코드, 상수, 정적 필드 저장
2. **힙 영역**: 객체와 배열 저장 (가비지 컬렉터 관리)
3. **스택 영역**: 지역변수와 매개변수 저장

### String 객체 생성 방식
1. **리터럴 방식**: `String str = "Hello";`
   - 문자열 풀(String Pool)에서 재사용
   - 같은 내용이면 같은 객체 참조

2. **new 생성자**: `String str = new String("Hello");`
   - 항상 새로운 객체 생성
   - 내용이 같아도 다른 객체

### 참조 변수 사용 시 주의사항
- null 체크를 통한 NullPointerException 방지
- 문자열 비교 시 equals() 메소드 사용
- 가비지 컬렉션을 위해 사용 완료된 객체는 null 할당